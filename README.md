# Underground Music Discovery Engine

## üéØ Project Goal
To create a smart recommendation engine that helps users discover **underground electronic music**. The system will provide a curated playlist that balances two key elements:

1.  **Relevance**: Tracks from artists similar to what the user already likes, providing a solid foundation of familiarity.
2.  **Discovery**: Hidden gems from unpopular ("underground") artists within the same genres, ensuring a fresh and exciting listening experience.

This hybrid approach is designed to deliver recommendations that are both perfectly tailored and full of surprises.

---

## ‚öôÔ∏è Core Recommendation Logic: A Hybrid Approach
The engine works by taking a user's favorite artist as a starting point and generating recommendations through two parallel paths, which are then mixed together.

1.  **User Input**: User provides a "seed" artist (e.g., "Ben Klock").

2.  **Path A: The Relevance Engine**
    - The system finds artists similar to the seed artist (e.g., "Marcel Dettmann", "DVS1") using the Last.fm API.
    - It then fetches the top tracks from these similar artists. These are high-quality tracks the user is statistically very likely to enjoy.

3.  **Path B: The Discovery Engine**
    - The system identifies the genre tags of the seed artist (e.g., "Techno", "Minimal").
    - It then queries our pre-compiled database of artists (`lastfm_artists_with_listeners.csv`) to find artists who share those tags but have a **low listener count** (our definition of "underground").
    - Finally, it fetches the top tracks from these newly discovered underground artists.

4.  **The Final Playlist**:
    - The system intelligently **mixes** tracks from both the Relevance and Discovery paths.
    - This mix can be weighted (e.g., 60% relevance, 40% discovery) to create a playlist that is as familiar or as adventurous as the user desires.

---

## üöÄ Project Phases

### Phase 1: Building the Underground Artist Database (Current Step)
- **Script**: `get_artists_by_tag.py`
- **Goal**: Systematically scan broad genre tags on Last.fm to build a foundational database of artists and their popularity.
- **Process**:
  1. Fetch thousands of artists for each tag (`techno`, `house`, etc.).
  2. For each unique artist, get their total listener count (our popularity metric).
  3. Store this data in `lastfm_artists_with_listeners.csv`. This file is the fuel for our Discovery Engine.

### Phase 2: Developing the Recommendation Script
- **Script**: `get_recommendations.py` (or similar)
- **Goal**: Implement the hybrid recommendation logic.
- **Process**:
  1. Take a seed artist as input.
  2. Execute Path A (Relevance) and Path B (Discovery) in parallel.
  3. Combine the results into a final ranked list of tracks.

### Phase 3: Building the User Interface
- **Framework**: Streamlit or Flask
- **Goal**: Create a simple web app for users to interact with the engine.
- **Features**:
  - An input box for the user to enter their seed artist.
  - A "tunable" parameter (like a slider) to control the mix between relevance and discovery.
  - A clean display of the final recommended playlist with links to listen.

---

## üé® User Experience & Data Visualizations
To make the discovery process more engaging and intuitive, the application will feature modern and sleek data visualizations. The goal is not just to provide a list of tracks, but to help the user *see* the connections in the music.

Potential visualizations include:

-   **Genre Cluster Map**: An interactive diagram where artists are plotted as nodes.
    -   Artists will be clustered together based on shared genre tags (`techno`, `house`, etc.).
    -   The size of each artist's node could represent their popularity (listener count), making it easy to spot the "underground" artists in a sea of bigger names.

-   **Recommendation Journey**: A visual representation of how the final playlist was built.
    -   This could show the user's "seed artist" at the center.
    -   Branches would extend out to "similar" artists (the Relevance path) and "underground" artists (the Discovery path), showing the origin of each recommendation.

-   **Underground Spectrum**: A simple bar chart or distribution plot that shows where the recommended tracks fall on the popularity scale, giving the user a clear sense of how "hidden" these gems really are.

---

## üíæ Data Storage
- **Primary Data**:
  - `lastfm_artists_with_listeners.csv`: Our core database of artists, their tags, and listener counts. Generated by `get_artists_by_tag.py`.
- **Generated On-the-Fly**:
  - Similar artist data and track data will be fetched in real-time by the recommendation script.

---

## üìö Useful Resources

- Last.fm API docs: https://www.last.fm/api
- Python Requests library: https://requests.readthedocs.io/
- Pandas for data manipulation: https://pandas.pydata.org/
- Streamlit for quick app dev: https://streamlit.io/

---

## ü§ù Collaboration & Future Work

- Add user authentication for personalized scrobble-based recommendations.
- Integrate other APIs (Spotify, YouTube) for richer metadata and audio previews.
- Add machine learning for advanced track clustering and similarity scoring.
- Cache API results to speed up recommendations for frequent queries.


